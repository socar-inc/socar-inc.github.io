<!DOCTYPE html>

<html>

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Java Map의 확장 인터페이스 NavigableMap 이야기 - SOCAR Tech Blog
    
  </title>

  <meta name="description" content="Java NavigableMap 이야기">

  <meta property="og:type" content="website"/>
  <meta property="og:url" content="https://tech.socarcorp.kr/dev/2021/10/19/sub-interfaces-navigablemap.html"/>
  <meta property="og:title" content="Java Map의 확장 인터페이스 NavigableMap 이야기"/>
  <meta property="og:description" content="Java NavigableMap 이야기"/>
  <meta property="og:site_name" content="SOCAR Tech Blog"/>
  <meta property="og:image" content="https://tech.socarcorp.kr/assets/images/sub-interfaces-navigablemap.jpeg"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:title" content="Java Map의 확장 인터페이스 NavigableMap 이야기"/>
  <meta name="twitter:description" content="Java NavigableMap 이야기"/>
  <meta name="twitter:image" content="https://tech.socarcorp.kr/assets/images/sub-interfaces-navigablemap.jpeg"/>


  <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

  <link rel="stylesheet" href="/assets/vendor/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css">
  <link rel="stylesheet" href="/assets/main.css">

  <link rel="canonical" href="https://tech.socarcorp.kr/dev/2021/10/19/sub-interfaces-navigablemap.html">
  <link rel="alternate" type="application/rss+xml" title="SOCAR Tech Blog" href="/feed.xml">
  <link rel="icon" type="image/png" href="/assets/icon/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icon/favicon-96x96.png">
</head>


<body>

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">SOCAR Tech Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/">🏠 Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/posts">✏️ Posts</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/categories">📔 Categories</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/tags">🏷 Tags</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/authors">✍🏻 Authors</a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead" style="background-image: url('/assets/images/sub-interfaces-navigablemap.jpeg')">
  
    <div class="overlay"></div>
    <div class="container">
      <div class="row">
        <div class="col-lg-9 col-md-9 mx-auto">
          <div class="post-heading">
            <h1 class="post-title">Java Map의 확장 인터페이스 NavigableMap 이야기</h1>
            
            <h2 class="subheading">Java NavigableMap 이야기</h2>
            
            <div class="post-meta">
              
              
                
                <span class="author"><a href="/authors#레이"><img src="/assets/authors/ray.png">레이</a></span>
              
                <br>
                <span class="date">2021-10-19</span>
                <br>
                <span class="category"><a href="/categories#">dev</a></span> 
                <br>
              
                <span class="tag"><a href="/tags#server">server</a></span>
              
                <span class="tag"><a href="/tags#java">java</a></span>
              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="toc toc-hidden" id="toc">
    </div>
    <div class="row">
      <div class="col-lg-9 col-md-9 mx-auto">
        <div class="post-content">
        <p>안녕하세요. 모빌리티 플랫폼 그룹 모비딕팀의 레이입니다.</p>

<p>문제 하나로 글을 시작합니다.</p>

<ul>
  <li>어떤 항목 중에서 임의의 선택을 하되 가중치를 두어야 한다면 어떻게 구현할 수 있을까요?</li>
  <li>예를 들어 빨강, 파랑, 초록 중 하나를 임의대로 추출하되 각각 5,3,2 만큼 가중치를 두고 싶습니다.</li>
</ul>

<p>뜬금없이 가중치 문제로 시작했는데, 이 글에서 제시하는 답은 아래에 있습니다.
일단 각자 아는 방법대로 구현해 보고 제 방법과 비교해 보시기 바랍니다.</p>

<h2 id="목차">목차</h2>

<ul>
  <li>Map 인터페이스와 세 가지 기본 구현체: HashMap, LinkedHashMap, TreeMap</li>
  <li>Map 기능을 확장한 몇 가지 서브 인터페이스</li>
  <li>오늘의 주제: NavigableMap</li>
  <li>NavigableMap 인터페이스 구현체</li>
  <li>간단한 사용 예제
    <ul>
      <li>1) 숫자 범위에 따른 값 할당</li>
      <li>2) 가중치 문제 풀이</li>
    </ul>
  </li>
  <li>NavigableMap 전제 조건:</li>
  <li>정리하며</li>
</ul>

<hr />

<h2 id="map-인터페이스와-세-가지-기본-구현체-hashmap-linkedhashmap-treemap">Map 인터페이스와 세 가지 기본 구현체: HashMap, LinkedHashMap, TreeMap</h2>

<p>요즘에는 인터페이스와 구현체를 구분해서 변수를 선언하는 방법이 거의 자리를 잡은 듯 합니다.
다른 언어는 모르겠지만 자바로 제한한다면 예전에는 선언과 구현체 타입을 같게 지정하는 경우가 많았습니다.</p>

<p>초기에 인터페이스 없이 달랑 구현체만 있던 <code class="highlighter-rouge">Hashtable</code>이야<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> 어쩔 수 없이</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Hashtable</span> <span class="n">hash</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hashtable</span><span class="o">();</span>
</code></pre></div></div>

<p>처럼 했을 수 있지만 컬렉션 프레임워크가 생긴 1.2 시절에도 이런 스타일은 흔히 볼 수 있었습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
</code></pre></div></div>

<p>그러다가 업계의 개발 지식이 전반적으로 높아진 덕분인지 설계와 구현을 분리한 선언을 하는 방법이 거의 필수처럼 자리잡기 시작한 듯 합니다.
이제는 앞선 맵 할당을 다음과 같이 하는 경우가 대부분입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
</code></pre></div></div>

<p>우리 관심사는 map으로서 기능, 그러니까 <strong>어떤 키로 대응하는(map) 값을 찾는 기능이지 맵의 구현체가 실제로 어떠한지는 관심 대상이 아닙니다.</strong><sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>
그런데 때로는 map의 키들이 어떤 순서를 유지하는지도 중요한 경우가 있습니다.
이런 때 사용할 수 있도록 준비해 놓은 구현체가 <code class="highlighter-rouge">LinkedHashMap</code>, <code class="highlighter-rouge">TreeMap</code> 입니다.
이런 경우에도 인터페이스를 사용한 선언에 구현체를 바꿔주기만 하면 이를 사용하는 다른 곳에서는 특별히 구현을 바꾸지 않더라도 다른 Map 구현체의 특징을 활용할 수 있습니다.</p>

<ul>
  <li><code class="highlighter-rouge">HashMap</code>은 저장하는 키에 특별한 순서를 보장하지 않습니다.
    <ul>
      <li>사실 대부분 map을 사용하는 목적 상 키 순서가 중요한 경우는 별로 없습니다.</li>
    </ul>
  </li>
  <li>키가 어떤 규칙에 따라 정렬이 되기를 원한다면 <code class="highlighter-rouge">TreeMap</code>을 사용하면 됩니다.</li>
  <li>map에 저장하는 순서에 따라 정렬이 되기를 원하면 <code class="highlighter-rouge">LinkedHashMap</code>을 사용하면 됩니다.</li>
</ul>

<p>보통은 이렇게 키의 정렬 순서를 특정하는 목적으로 세 가지 구현체를 상황에 맞게 사용하는 경우가 대부분입니다.
그리고 많은 사람들이 관심있는 동시성 처리와 관련한 <code class="highlighter-rouge">ConcurrentHashMap</code> 같은 특수한 환경 아래 동작하는 구현체 이야기는 쉽게 찾아 볼 수 있는데, 이 글에서는 조금 다른 이야기를 해 보려고 합니다.</p>

<hr />

<h2 id="map-기능을-확장한-몇-가지-서브-인터페이스">Map 기능을 확장한 몇 가지 서브 인터페이스</h2>

<p><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Map.html">Java API Doc</a>(v9)을 보면 <code class="highlighter-rouge">Map</code>의 서브 인터페이스는 11개 씩이나 됩니다.
이 중에서 “Map” 하고 관계 있어 보이는 대상은 다음처럼 7개입니다</p>

<ul>
  <li><code class="highlighter-rouge">ConcurrentMap</code></li>
  <li><code class="highlighter-rouge">ConcurrentNavigableMap</code></li>
  <li><code class="highlighter-rouge">NavigableMap</code></li>
  <li><code class="highlighter-rouge">ObservableMap</code></li>
  <li><code class="highlighter-rouge">ObservableMapValue</code></li>
  <li><code class="highlighter-rouge">SortedMap</code></li>
  <li><code class="highlighter-rouge">WritableMapValue</code></li>
</ul>

<p>7가지 뿐만 아니라 11가지 인터페이스 모두를 다루었으면 좋겠지만 이 글에서는 이 중에서 <code class="highlighter-rouge">NavigableMap</code>이 무엇인지, <code class="highlighter-rouge">NavigableMap</code>의 구현체는 무엇인지를 이야기합니다.</p>

<hr />

<h2 id="오늘의-주제-navigablemap">오늘의 주제: NavigableMap</h2>

<p><code class="highlighter-rouge">NavigableMap</code>을 설명하는 내용부터 약간 살펴 보겠습니다.
(<a href="https://docs.oracle.com/javase/9/docs/api/java/util/NavigableMap.html">https://docs.oracle.com/javase/9/docs/api/java/util/NavigableMap.html</a>)</p>

<p>문서를 보면, 첫 줄에</p>

<blockquote>
  <p>A <code class="highlighter-rouge">SortedMap</code> extended with navigation methods returning the closest matches for given search targets.</p>
</blockquote>

<p>이라고 했습니다.
이 문장이 <code class="highlighter-rouge">NavigableMap</code>의 특징을 설명하는 전부입니다.
이어서 다음 문장을 읽어 보겠습니다.</p>

<blockquote>
  <p>Methods <code class="highlighter-rouge">lowerEntry(K)</code>, <code class="highlighter-rouge">floorEntry(K)</code>, <code class="highlighter-rouge">ceilingEntry(K)</code>, and <code class="highlighter-rouge">higherEntry(K)</code> return <code class="highlighter-rouge">Map.Entry</code> objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a given key, returning null if there is no such key.</p>
</blockquote>

<p>이 문장에서 어떻게 사용을 하는지 잘 설명하고 있습니다.
그런데 이 내용만 가지고 당장 어디에 써야겠다고 생각이 떠오르기는 쉽지 않습니다.
사실 저도 그러했습니다.
<code class="highlighter-rouge">NavigableMap</code>이 무엇인지는 오래 전에 공부했지만 특별히 쓸 만한 곳은 없었습니다.
그러다가 최근 어떤 문제를 해결하려고 고민하던 중 문득 이 자료구조가 떠올랐고, 테스트 코드를 몇 줄 구현해 보면서 다행히 생각대로 잘 풀렸습니다.
공부한지 한참 지난 후 이제서야 쏘카에서 처음으로 실제 필요한 곳에 사용할 기회가 생긴 셈이지요.</p>

<p>조금 더 API 문서를 훑어 보겠습니다.</p>

<p>이 “인터페이스”는 <code class="highlighter-rouge">SortedMap</code><sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> 인터페이스를 상속합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NavigableMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SortedMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>“인터페이스”를 강조했습니다.
구현체가 아닌 인터페이스입니다.
인터페이스니까 어떤 동작을 제공하는지 계속해서 API문서를 살펴 보겠습니다.
앞서 보았던 두 번째 문장이 동작을 이해하려면 필요한 핵심 내용입니다.</p>

<p>jdk 버전 9 기준 <code class="highlighter-rouge">NavigableMap</code> 고유 메서드는 21개 이지만 이 중에서도 개인적으로 <code class="highlighter-rouge">NavigableMap</code>의 특징을 잘 드러낸다고 생각하는 <code class="highlighter-rouge">floorEntry()</code>, <code class="highlighter-rouge">ceilingEntry()</code>, <code class="highlighter-rouge">lowerEntry()</code>, <code class="highlighter-rouge">higherEntry()</code> 네 가지를 설명하겠습니다.</p>

<h2 id="navigablemap-인터페이스-구현체">NavigableMap 인터페이스 구현체</h2>

<p>앞에도 강조했지만 <code class="highlighter-rouge">NavigableMap</code>은 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_(%EC%9E%90%EB%B0%94)">인터페이스</a>입니다.
그렇다면 구현체는 무엇일까요?</p>

<p>그냥 <code class="highlighter-rouge">TreeMap</code>을 사용하면 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">();</span>          <span class="c1">// (1)</span>
<span class="nc">NavigableMap</span> <span class="n">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">();</span> <span class="c1">// (2)</span>
</code></pre></div></div>

<p>약간 혼란을 느끼는 분이 있을 수도 있는데, 그래서 앞에 “인터페이스”를 강조했습니다.
같은 <code class="highlighter-rouge">TreeMap</code> 구현체를 어떤 인터페이스로 사용하느냐에 따라 관점이 달라집니다.
어쩌면 이 이야기가 더욱 중요합니다.
우리의 관심사가 단순히 (키를 정렬한) <code class="highlighter-rouge">Map</code>인지, 제시한 요소와 방향에 가장 가까운 키를 찾으려는지에 따라 같은 <code class="highlighter-rouge">TreeMap</code> 구현체라 해도 사용하는 API가 다릅니다.</p>

<p>(1) 처럼 선언하면 <code class="highlighter-rouge">TreeMap</code> 구현체를 <code class="highlighter-rouge">Map</code> 인터페이스로 들여다본다는 뜻이라서 <code class="highlighter-rouge">Map</code>이 제공하는 25개의 메서드만 사용할 수 있으나,
(2) 처럼 선언하면 실제 메모리에 올라가는 구현체는 (1)과 같은 <code class="highlighter-rouge">TreeMap</code>이지만 <code class="highlighter-rouge">NavigableMap</code>이 추가로 제공하는 고유한 메서드 21개를 더 사용할 수 있습니다<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>.</p>

<p>당연하게도 이러한 선언은 불가능합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NavigableMap</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
<span class="nc">NavigableMap</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">();</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HashMap</code>, <code class="highlighter-rouge">LinkedHashMap</code>은 <code class="highlighter-rouge">NavigableMap</code> 인터페이스를 상속하지 않은 구현체입니다.</p>

<p><code class="highlighter-rouge">Map</code>의 메서드는 25개나 되지만 사실상 <code class="highlighter-rouge">get(key)</code>, <code class="highlighter-rouge">put(key, value)</code> 말고는 사용하는 일이 거의 없습니다.
비슷하게 <code class="highlighter-rouge">NavigableMap</code>의 21개 메서드 중 4가지 메서드의 특징만 살펴보면 <code class="highlighter-rouge">NavigableMap</code>을 충분히 사용할 수 있으리라고 생각합니다<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>.</p>

<h2 id="간단한-사용-예제">간단한 사용 예제</h2>

<h3 id="1-숫자-범위에-따른-값-할당">1) 숫자 범위에 따른 값 할당</h3>

<p>매우 간단한 예제를 살펴 보겠습니다<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup>.</p>

<p>(1부터 100까지) 숫자 범위에 따라 다른 방을 배정하려고 합니다.
if - else 구문을 사용하면 이 정도 되겠지요?</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="p">&gt;</span> <span class="m">75</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// num &lt;= 100</span>
    <span class="s">"봄"</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="p">&gt;</span> <span class="m">50</span> <span class="p">&amp;&amp;</span> <span class="n">num</span> <span class="p">&lt;=</span> <span class="m">75</span><span class="p">)</span> <span class="p">{</span>
    <span class="s">"여름"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="p">&gt;</span> <span class="m">25</span> <span class="p">&amp;&amp;</span> <span class="n">num</span> <span class="p">&lt;=</span> <span class="m">50</span><span class="p">)</span> <span class="p">{</span>
    <span class="s">"가을"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span> <span class="c1">// num &gt; 0</span>
    <span class="s">"겨울"</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>나쁘지 않습니다.
아마도 여러분은 더 좋은 구현 방법을 알고 있으리라 생각합니다.</p>

<p><code class="highlighter-rouge">NavigableMap</code>으로 표현하면 어떨까요?
지금까지 했던 이야기를 바탕으로 이미 구현 방법을 떠올린 분도 계실 수 있다고 생각합니다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">m</span><span class="p">:</span> <span class="nc">NavigableMap</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">,</span> <span class="nc">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nc">TreeMap</span><span class="p">()</span>
<span class="n">m</span><span class="p">[</span><span class="m">100</span><span class="p">]</span> <span class="p">=</span> <span class="s">"봄"</span>
<span class="n">m</span><span class="p">[</span><span class="m">75</span><span class="p">]</span>  <span class="p">=</span> <span class="s">"여름"</span>
<span class="n">m</span><span class="p">[</span><span class="m">50</span><span class="p">]</span>  <span class="p">=</span> <span class="s">"가을"</span>
<span class="n">m</span><span class="p">[</span><span class="m">25</span><span class="p">]</span>  <span class="p">=</span> <span class="s">"겨울"</span>

<span class="k">return</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">ceilingEntry</span><span class="p">(</span><span class="n">num</span><span class="p">).</span><span class="nf">getValue</span><span class="p">()</span>
</code></pre></div></div>

<p>대략 이 정도 코드인데 전반적인 느낌을 이해하기는 어렵지 않으리라 생각합니다<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>.
ceiling 뜻 그대로, 전달한 인자보다 큰 쪽으로 가장 인접한 키값을 찾습니다.</p>

<blockquote>
  <p>Returns the least key greater than or equal to the given key, or null if there is no such key.</p>
</blockquote>

<p>만약 <code class="highlighter-rouge">num = 69</code> 였다면 69에 해당하는 키는 없지만 69보다 크면서 가장 가까운(작은) 키인 75를 선택합니다.
즉, (75, “여름”)이 해당하는 엔트리입니다.</p>

<p><code class="highlighter-rouge">floorEntry()</code>는 반대로 전달한 인자보다 작은 쪽으로 가장 인접한 값을 찾겠지요?
물론 위/아래로 범위를 넘어서는 값을 주면 찾을 수 있는 값이 없습니다.
API 문서를 보면 이 경우 <code class="highlighter-rouge">null</code>을 반환한다고 명시했습니다.
위의 예제에서는 <code class="highlighter-rouge">m.ceilingEntry(101)</code>이나 <code class="highlighter-rouge">m.floorEntry(0)</code>이 <code class="highlighter-rouge">null</code>입니다.
이런 경우 상/하한 경계를 찾을 수 있는 장치로 <code class="highlighter-rouge">higherEntry()</code>, <code class="highlighter-rouge">lowerEntry()</code>가 있습니다.</p>

<p><code class="highlighter-rouge">NavigableMap</code>이 가능하려면 어떤 전제 조건이 필요합니다.
바로 “키를 어떤 순서대로 정렬해 놓아야 한다”겠지요.
<code class="highlighter-rouge">NavigableMap</code>의 상위 인터페이스가 <code class="highlighter-rouge">SortedMap</code>이기도 하지만 구현체인 <code class="highlighter-rouge">TreeMap</code>이 이러한 전제 조건을 만족하는 구현체입니다.
다른 <code class="highlighter-rouge">Map</code> 구현체를 만들기 보다는 <code class="highlighter-rouge">TreeMap</code>에 floor/ceil 등의 구현을 추가하는 편이 훨씬 합리적이었으리라 추측합니다.</p>

<p><code class="highlighter-rouge">TreeMap</code>을 그저 키를 정렬한 맵 정도로 쓰다가 이제는 그 안에 숨어 있던 <code class="highlighter-rouge">SortedMap</code>과 <code class="highlighter-rouge">NavigableMap</code>이라는 다른 모습을 이해했습니다.
그렇다면 처음부터 <code class="highlighter-rouge">TreeMap</code>으로 선언하면 “키가 정렬된 <code class="highlighter-rouge">Map</code>“이라는 특징을 취하면서 동시에 <code class="highlighter-rouge">SortedMap</code>, <code class="highlighter-rouge">NavigableMap</code>이 제공하는 모든 기능을 다 쓸 수 있는데 왜 <code class="highlighter-rouge">TreeMap</code>을 타입으로 쓰지 않을까요?
이 내용은 글의 주제를 벗어나므로 깊이 다루지는 않겠지만 글 후반부에 설명하겠습니다.</p>

<p>조금 더 쓸모있는 예제를 살펴볼까요?</p>

<h3 id="2-가중치-문제-풀이">2) 가중치 문제 풀이</h3>

<p>글 처음에 보여드린 문제 풀이입니다.
여러분은 어떤 방법으로 풀어 보셨나요? 해결 방법은 다양하지만 <code class="highlighter-rouge">NavigableMap</code>을 활용하면 비교적 간단하게 풀 수 있습니다.
비율이 2:3:5 이므로 키를 각각 2, 5(2+3), 10(2+3+5)으로 정합니다.
약간은 계산이 필요하네요.</p>

<p>조금 더 이해하기 쉽도록 코드 위에 주석을 활용해 간단한 그림으로 표현했습니다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// | &lt;-------5-------- | &lt;---3---- | &lt;-2-- |</span>
<span class="c1">// |         R         |     G     |   B   |</span>
<span class="c1">// 10  9   8   7   6   5   4   3   2   1  (0)</span>

<span class="kd">val</span> <span class="py">map</span><span class="p">:</span> <span class="nc">NavigableMap</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">,</span> <span class="nc">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nc">TreeMap</span><span class="p">()</span>
<span class="n">map</span><span class="p">[</span><span class="m">10</span><span class="p">]</span> <span class="p">=</span> <span class="s">"빨강"</span>
<span class="n">map</span><span class="p">[</span><span class="m">5</span><span class="p">]</span>  <span class="p">=</span> <span class="s">"파랑"</span>
<span class="n">map</span><span class="p">[</span><span class="m">2</span><span class="p">]</span>  <span class="p">=</span> <span class="s">"초록"</span>
</code></pre></div></div>

<p>그리고 <code class="highlighter-rouge">Random</code>을 써서 이 맵을 탐색합니다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">color</span> <span class="p">=</span> <span class="n">map</span><span class="p">.</span><span class="nf">ceilEntry</span><span class="p">(</span><span class="nc">Random</span><span class="p">.</span><span class="nf">nextInt</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">)).</span><span class="nf">getValue</span><span class="p">()</span>
</code></pre></div></div>

<p>이 문제 같은 경우에는 간격이 중요합니다.
간격만큼 랜덤으로 선택한 값이 걸릴 확률, 즉 가중치를 결정합니다.
선택한 값에 따라 경계값으로 설정한 키를 찾아가는 구조입니다.</p>

<ul>
  <li>1, 2 가 나온다면: “파랑”,</li>
  <li>3, 4, 5 라면: “초록”,</li>
  <li>6, 7, 8, 9, 10 은: “빨강”</li>
</ul>

<p>을 반환하겠지요?
문제에서 요구한 5:3:2 가중치로 항목을 선택합니다.</p>

<p>매우 직관적이면서도 간결한 구현입니다.</p>

<hr />

<h2 id="navigablemap-전제-조건-sortedmap">NavigableMap 전제 조건: SortedMap</h2>

<p>만약 <code class="highlighter-rouge">NavigableMap</code>을 구현한다고 가정한다면 키 항목 구성은 어떤 전제 조건이 필요할까요?
<code class="highlighter-rouge">NavigableMap</code>에서 제시하는 키를 찾는 방법을 다시 살펴보면, 어떤 값을 주고 이 값 보다 크거나 작은 방향으로 가장 가까이 위치한 키를 찾습니다.
즉, 키 요소를 어떤 기준에 따라 정렬해 놓지 않으면 안 됩니다.
그래서 <code class="highlighter-rouge">NavigableMap</code>의 상위 인터페이스로서 <code class="highlighter-rouge">SortedMap</code>은 매우 자연스런 모습입니다.
Java에서는 <code class="highlighter-rouge">SortedMap</code>이나 <code class="highlighter-rouge">NavigableMap</code> 구현체가 따로 존재하지 않고 <code class="highlighter-rouge">TreeMap</code> 하나로 이 두 가지 인터페이스를 모두 만족하도록 구현해 놓았습니다.</p>

<p><code class="highlighter-rouge">NavigableMap</code>은 <code class="highlighter-rouge">Map</code>, <code class="highlighter-rouge">SortedMap</code>을 확장(상속)한 인터페이스라서 <code class="highlighter-rouge">Map</code>과 <code class="highlighter-rouge">SortedMap</code>에서 제공하는 api(메서드)를 모두 사용할 수 있겠지요.
<code class="highlighter-rouge">SortedMap</code>으로 선언하든 <code class="highlighter-rouge">NavigableMap</code>으로 선언하든 어차피 <code class="highlighter-rouge">TreeMap</code>을 할당해야 할 테니 구현체 차이는 없겠지만 그래도 사용 목적에 따라 적절한 인터페이스를 사용해야 합니다.
<code class="highlighter-rouge">SortedMap</code>이 필요한 구현인데 굳이 <code class="highlighter-rouge">NavigableMap</code>으로 선언해서 훗날 코드를 읽는 누군가에게 혼란을 초래할 필요는 없겠지요.
같은 <code class="highlighter-rouge">TreeMap</code>을 할당하더라도 정말로 필요한 목적에 따라 인터페이스를 적절히 구분해 사용했을 때 해당 코드를 들어다보는 동료들이 조금이나마 모호한 상황을 훨씬 적게 겪을 수 있습니다.</p>

<ul>
  <li>그저 정렬된 키셋이 필요한 경우라면 <code class="highlighter-rouge">Map</code>인터페이스로 충분합니다.</li>
  <li>정렬된 키를 기준으로 이런저런 부분 맵이 필요하다면 <code class="highlighter-rouge">SortedMap</code> 인터페이스를,</li>
  <li>키 탐색이 필요하면 <code class="highlighter-rouge">NavigableMap</code>을 사용합니다.</li>
</ul>

<p>그냥 <code class="highlighter-rouge">TreeMap</code>으로 선언했다면 코드를 자세히 들여다보지 않는 이상 어떤 목적으로 사용하려 했는지 알기가 어렵겠지요.
그나마 주석을 달아 놓았다면 조금은 덜 혼란스러울 수도 있겠지만 코드 자체에 의도와 목적을 분명하게 드러낼 수 있다면 그렇게 하는 편이 더 좋습니다.</p>

<p><code class="highlighter-rouge">SortedMap</code>도 흥미로운 주제이니 각자 살펴 보시기 바랍니다.
저는 아직 <code class="highlighter-rouge">SortedMap</code>을 써야 할 만한 문제를 겪지는 않았습니다.
언젠가는 이를 써서 해결해야 할 문제를 마주하게 될 날도 오겠지요.</p>

<hr />

<h2 id="정리하며">정리하며</h2>

<p>Map은 상당히 많이 사용하는 자료 구조입니다.
대부분 <code class="highlighter-rouge">HashMap</code> 정도면 충분하지만 때로는 키 정렬 순서 때문에 <code class="highlighter-rouge">LinkedHashMap</code>, <code class="highlighter-rouge">TreeMap</code>을 사용하는 경우가 종종 있습니다.
비슷한 <code class="highlighter-rouge">HashMap</code> 계열에서도 동시성 문제 때문에 <code class="highlighter-rouge">ConcurrentHashMap</code>을 사용하는 경우도 있고 메모리 문제 때문에 <code class="highlighter-rouge">WeakHashMap</code>을 사용하는 경우도 있지만 상황에 따라 구현체를 바꾸었을 뿐 <code class="highlighter-rouge">Map</code> 인터페이스 범주를 벗어나지 않는 선에서 사용하는 경우가 대부분입니다.</p>

<p>내부 구현의 차이가 있지만 단순한 키 - 값 대응만 사용하는 <code class="highlighter-rouge">Map</code> 을 넘어서 <code class="highlighter-rouge">Map</code>의 확장 인터페이스인  <code class="highlighter-rouge">NavigableMap</code> 관점으로 <code class="highlighter-rouge">TreeMap</code> 구현체를 어떻게 사용할 수 있는지 간략히 살펴 보았습니다.</p>

<p>다음에는 <code class="highlighter-rouge">NavigableMap</code>으로 조금 더 깊이 있는 활용 사례를 선보이는 시간을 갖도록 하겠습니다.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>엄밀히 이야기하면 <code class="highlighter-rouge">Hashtable</code>은 추상 클래스인 <code class="highlighter-rouge">Dictionary</code>를 상속한 구현체입니다. 자바 설계 당시 인터페이스 개념은 추상 클래스보다 늦게 도입한 개념입니다. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>제네릭은 이 글에서 다루는 주제가 아니기도 하고 다룰 필요도 없어서 과감히 생략합니다. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p><code class="highlighter-rouge">NavigableMap</code>이 <code class="highlighter-rouge">SortedMap</code>을 상속하고 <code class="highlighter-rouge">SortedMap</code>이 <code class="highlighter-rouge">Map</code>을 상속하니 <code class="highlighter-rouge">NavigableMap</code> 이전에 <code class="highlighter-rouge">SortedMap</code> 특징을 설명하면 더욱 좋겠지만 주제를 벗어난다고 판단하여 생략합니다.  다만 <code class="highlighter-rouge">NavigableMap</code>을 설명하다 보면 매우 간략하기는 해도 자연스럽게 <code class="highlighter-rouge">SortedMap</code> 특성도 언급하기는 합니다. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p><code class="highlighter-rouge">SortedMap</code> 까지 생각하면 조금 차이는 있으나 넘어가겠습니다 <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>제가 만든 애플리케이션에서도 4개의 메서드만 사용합니다. <a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>여기부터 편의 상 코틀린 코드를 사용합니다. <a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>num 입력값을 1~100으로 제한하지 않으면 이 구현에는 문제가 있지만, 조건을 제한하여 실행했다고 가정한다면 문제는 없습니다. <a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>
        
        <hr>
        <div class="clearfix">
          
          <a class="btn btn-primary float-left" href="/dev/2021/08/19/join-in-socar-android.html" data-toggle="tooltip" data-placement="top" title="쏘카 안드로이드 팀 신입 개발자 미뇽의 입사기">&larr; Previous<span class="d-none d-md-inline">
              Post</span></a>
          
          
          <a class="btn btn-primary float-right" href="/dev/2021/11/01/socar-developer-meetup.html" data-toggle="tooltip" data-placement="top" title="수요일엔 수요미식회, 금요일은 개발밋업회">Next<span class="d-none d-md-inline">
              Post</span> &rarr;</a>
          
        </div>
        <div>
          <p class="recuit">쏘카는 언제나 쏘카 서비스를 함께 만들며 기술적인 문제를 함께 풀어나갈 능력있는 개발자/디자이너/기획자/데이터 사이언티스트 등을 모시고 있습니다. 자세한 내용은 <a href="https://bit.ly/SOCAR-RECRUIT">쏘카 채용공고 페이지</a>를 확인 부탁드립니다 :)</p>
        </div>
      </div>
    </div>
    <!-- utterance comments -->
    <script src="https://utteranc.es/client.js"
        repo="socar-inc/techblog-comments"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>
  </div>

<script>
  // ref https://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '#toc',
    contentSelector: '.post-content',
    headingSelector: 'h1, h2, h3',
    hasInnerContainers: true,
    collapseDepth: 6,
    linkClass: 'toc-link'
  });


  $(window).on('scroll', function() {
      let scrollTop = $(window).scrollTop()
      let scrollBottom =  scrollTop + $(window).height()
      let contentOffsetTop = $(".post-content").offset().top
      let contentOffsetBottom = contentOffsetTop + $(".post-content").height()
      let elementHeight = $(".post-content").height(); 

      if ((scrollTop < contentOffsetTop) || (scrollBottom >= contentOffsetBottom)) {
        // $('.toc').css('visibility', 'hidden')
        $('.toc').addClass("toc-hidden")
      }
      else if (scrollTop >= contentOffsetTop) {
        $(".toc").removeClass("toc-hidden")
      }
  });
</script>


  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-9 mx-auto">
        <ul class="list-inline text-center">
          
          
          
          <li class="list-inline-item">
            <a href="https://www.facebook.com/socarsharing">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-facebook-f fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          
        </ul>
        <p class="copyright text-muted">Copyright &copy; SOCAR 2023 | tech_branding@socar.kr</p>
      </div>
    </div>
  </div>
</footer>


  <script src="/assets/vendor/jquery/jquery.min.js"></script>
<script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/clean-blog.min.js"></script>
<script src="/assets/scripts.js"></script>
<script src="/assets/mermaid-8.2.3.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-30551922-27"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-30551922-27');
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MZ79TFM');</script>
<!-- End Google Tag Manager -->


</body>

</html>
